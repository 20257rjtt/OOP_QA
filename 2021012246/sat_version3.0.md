

# 第一版说明

在第一版中，我们实现了DPLL的基本功能，可以求解一些SAT问题。具体的实现方式简要说明如下：

我们建立了三个类：

1、合取范式类CNF，用于存储输入的合取范式。

2、子句类SubSentence，对单个子句进行操作。

3、DPLL_SOLVER求解类，用于输入cnf问题进行求解。

代码实现的流程图如下：

1、文件读入![文件读入](/Users/wangjh/Desktop/WAR/02-computer/cs/Final_project/流程图/文件读入.png)

2、进行求解![求解](/Users/wangjh/Desktop/WAR/02-computer/cs/Final_project/流程图/求解.png)

（我的实现中会固定初始的变量个数variable_number，在整个程序中保持不变，这样可能导致一些内存的浪费，比如有些变量已经不出现了，但我在子句类中每个子句还会为其保留位置）

# 第二版说明

相比于第一版来说，第二版调整了如下几点：

1、调整了变量指标的搜索顺序，不像第一版是顺序搜索。搜索规则如下：优先对整个合取范式中实际出现次数最多的变量进行赋值。

2、调整了对某个变量的赋值顺序，不像第一版中不论是对哪个变量都是先赋成true，再赋成false。赋值顺序如下：如果该变量x在整个合取范式中以-x的形式出现的多，那么先赋成false，否则先赋成true。

# 第三版说明

在第三版中，我们增加了求解4*4数独的功能。

设数独大小为NUM（比如对于4*4数独NUM就是4），每个格子(i,j)上赋予NUM个变量，三维格点变量数组与一维布尔变量数组的对应关系：(i,j;k) ---i×NUM^2+j×NUM+k，0=<i,j,k<NUM

格点变量(i,j;k)表示在格子(i,j)上是否填数k

注意实际中变量是从1开始的，而上面是从0开始的，进行转换即可。

新建立了两个类：

1、Sudoku类，这个类用于生成数独游戏求解所需的合取范式

2、SudokuProblem类，这个类主要用于得到数独与输出求解结果

代码实现如下：

## Sudoku类

 1、 生成“每个格子只能填写一个数”对应的合取范式，传入位置

有如下两类子句：![每格](/Users/wangjh/Desktop/WAR/02-computer/cs/Final_project/流程图/每格.jpeg)

2、生成“两个格子不能填同一个数”对应的合取范式：![两个格子](/Users/wangjh/Desktop/WAR/02-computer/cs/Final_project/流程图/两个格子.jpeg)

3、生成“每行每列每大格填的数互不相同”对应的合取范式

用2遍历每行每列每大格所有格子对即可。

4、生成“数独规则所对应的合取范式”

把上面的1，2，3合成一个cnf即可。

## SudokuProblem类

首先从文件中读入数独题目，再在Sudoku得到的合取范式的基础上添加新的字句即可。

比如在格子(i;j)上已知填写的是k，那么只需要新建一个只有i×NUM^2+j×NUM+k变量出现的子句就可以保证求解的结果与已知条件相同。

