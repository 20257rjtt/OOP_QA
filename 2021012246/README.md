# 说明

1、本目录下的Debug文件记录我在编写程序时出现的一些错误

2、sat_version3.0记录的是src目录下sat文件代码实现的过程，即求解sat问题的DPLL算法

3、sudoku_version1.0记录的是src目录下sudoku文件代码实现的内容，求解数独问题的算法



# CNF文件的输入格式：

书写合取范式文件需要满足如下规则：https://zhuanlan.zhihu.com/p/348334847

**a )** 文件主要由 **注释块** 和 **子句块** 两部分组成，其中注释块一般用作变量的声明，每个变量占一行；子句块主要书写问题的条件 (即 cnf 范式)，每个子句占一行。文件用标记行 `p cnf {num_var} {num_clauses}` 来区分 **注释块** 和 **子句块** 两部分，即该行之前是注释，该行之后是子句。这里的 `{num_var}` 表示变量的个数，`{num_clauses}` 表示子句的个数。

```text
// 表示有 10 个变量，20 个子句。
p cnf 10 20
```

**b ) 在注释块中，每行声明一个变量**，且以小写字母 `c` 开头。注释的形式为 `c {var_id} {var_name}`，其中 `var_id` 表示变量的序号，如 1,2,…，注意此序号必须从 1 开始且连续。`var_name` 表示变量的名称。这样做是为了后续子句书写的便利，即用序号表示变量。

```text
// 声明变量 a，其序号为 1；声明变量 b，其序号为 2
c 1 a
c 2 b
```

**c ) 在子句块中，每行表示一个析取子句** (仅包含或操作)，且以数字 `0` 结尾。如 `1 -2 0` 表示 ( a ∨ ¬ b )这个析取子句。`2 -1 0` 表示 ( b ∨ ¬ a ) 这个析取子句。数字前面的符号表示非 (¬) 的含义。子句块中所包含的所有行用与操作连接起来就是我们的 cnf 了。因此在 SAT 问题中，如果要使得最终的合取范式 (CNF) 结果为真，则必须要求每一行的析取子句结果为真。

```text
// 子句含义为 (a OR !b)
1 -2 0
// 子句含义为 (b OR !a)
2 -1 0
```

综上所述，我们可以根据 `a,b` 构建一个简单的 cnf，并存储在 `.dimacs` 文件中，文件内容为，

```text
c 1 a
c 2 b
p cnf 2 2
1 -2 0
2 -1 0
```

2、根据输入的合取范式（cnf）判断该范式是否可满足，若可满足则返回一组可满足的真值指派。

# 数独文件输入格式

第一行输入数独大小的平方根：比如4*4数独输入2

之后每行输入三个数i j k

表示在第i行第j列的格子里面填入了数k
